<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>스코프</title>
</head>
<body>
	<script>
	/*---------------------------------------------------------------------- 
		1. 스코프(scope) : 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다.
		- 변수의 스코프가 어떤 함수라고 말할 때, 함수를 실제 호출할 때까지 함수 바디의 정해진 매개변수가 존재하지 않는다.
		- 함수는 여러 번 호출할 수 있다.
		- 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라진다.

		2. 변수와 상수는 만들기 전에 존재하지 않는다.(즉, let이나 const로 선언하기 전에는 스코프 안에 존재하지 않는다.)
		- 변수를 선언한다 : 식별자를 주어서 그 존재를 알린다.
		- 정의 : 선언과 함게 값도 부여하는 것
		* 자바스크립트는 모든 변수를 선언하는 동시에 값이 주어지므로(명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않는다.
	---------------------------------------------------------------------- */
	

	/*---------------------------------------------------------------------- 
		< 7.1 스코프와 존재 >
		1. 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 스코프 안에 있지 않다.
		- 스코프 : 프로그램의 현재 실행중인 컨텍스트에서 현재 보이고 접근할 수 있는 식별자
		- 존재한다 : 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다
		- 존재하지만 스코프 안에는 없는 변수 : 자바스크립트의 가비지 콜렉션 자동으로 일어나서 프로그래머가 신경 쓸 필요X
	---------------------------------------------------------------------- */

		
	/*----------------------------------------------------------------------  
		< 7.2 정적 스코프와 동적 스코프 >
		1. 정적 스코프 : 어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다.(호출할 때 알 수 있는 것은X)
		- 자바스크립트의 정적 스코프는 전역 스코프, 블록 스코프, 함수 스코프에 적용된다.
	---------------------------------------------------------------------- */
	const x = 3; // 함수 f를 정의할 때 존재
		
	function f() { // 자신이 정의될 때 접근할 수 있었던 식별자에게는 접근가능, 호출할 때 스코프에 있는 식별자에는 접근할 수X
		console.log('7.2 정적 스코프와 동적 스코프: '+x); // 3
//		console.log(y); // Uncaught ReferenceError: y is not defined
	}
			
	{ // 새 스코프
		const y = 5; // 함수f를 정의할 때 존재하지X, 다른 스코프에 존재
		f();
	}
		
	/*----------------------------------------------------------------------  
		< 7.3 정적 스코프 - 전역 스코프 >
		1. 전역 스코프 : 프로그램을 시작할 때 암시적으로 주어지는 스코프(어떤 함수도 호출하지 않았을 때 실행 흐름)
		- 전역 스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수 있다.
		- 전역 변수 : 전역 스코프에서 선언된 것들
		- 문제점 : 함수가 호출하는 컨텍스트(스코프)에 의존적이다. -> 사용자 정보를 단일 객체에 보관하는 방법이 더 좋다.
	---------------------------------------------------------------------- */	
	let user = {
		name : "Irena",
		age : 25,
	};
		
	function greet(user) { // 명시적으로 user를 전달받아 전역 스코프에 의존하지 않게 만듦
		console.log(`Hello, ${user.name}!`);
	}	
	
	function getBirthYear(user) {
		return new Date().getFullYear() - user.age;
	}	
		
	/*----------------------------------------------------------------------  
		< 7.4 정적 스코프 - 블록 스코프 >
		1. let, const : 식별자를 블록 스코프에서 선언한다.
		2. 블록 : 문을 중괄호로 묶은 것
		3. 블록스코프 : 문을 중괄호로 묶은 스코프에서만 보이는 식별자 
	---------------------------------------------------------------------- */		
	
		
	/*----------------------------------------------------------------------  
		< 7.5 변수 숨기기 >
		1. 내부 블록의 x는 외부 블록에서 정의한 x와는 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는(가리는) 효과가 있다.
		2. 스코프 체인 : 스코프의 계층적인 성격 때문에 어떤 변수가 스코프에 있는지 확인할 수 있음
		- 스코프 체인에 있는 모든 변수는 스코프에 있는 것이며, 숨겨지지 않았다면 접근할 수 있음	
	---------------------------------------------------------------------- */		
	{
		// 외부 블록
		let x = { color:"blue" };
		let y = x; // y 와 x는 같은 객체를 가리킨다.
		let z = 3;
		{
			// 내부 블록
			let x = 5; // 바깥의 x는 가려짐
			console.log('7.5 변수 숨기기 내부블록: '+x); // 5
			console.log('7.5 변수 숨기기 내부블록: '+y.color); // "blue", y가 가리키는 외부 스코프의 x가 가리키는 객체는 스코프 안에 있다.
			
			y.color = "red";
			console.log('7.5 변수 숨기기 내부블록: '+z); // 3; z는 숨겨지지X
		}
			
		console.log('7.5 변수 숨기기 외부블록: '+x.color); // "red"; 객체는 내부 스코프에서 수정됨
		console.log('7.5 변수 숨기기 외부블록: '+y.color); // "red"; x와 y는 같은 객체를 가리킴
		console.log('7.5 변수 숨기기 외부블록: '+z); // 3
	}
		
		
	/*----------------------------------------------------------------------  
		< 7.6 함수, 클로저, 정적 스코프 >
		1. 클로저 : 함수가 특정 스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는 것(스코프를 함수 주변으로 좁히는 것)
	---------------------------------------------------------------------- */
		// Ex1)
		let globalFunc; // 정의되지 않은 전역 함수, 블록 안에서 값을 할당받음
		{
			let blockVar = 'a'; // 블록 스코프에 있는 변수
			globalFunc = function() {
				console.log('7.6 함수 클로저, 정적 스코프 예제1: '+ blockVar);
			}
		}
		
		globalFunc(); // "a" : 스코프에서 빠져나왔음에도 불구하고 blockVar에 접근할 수 있음. 
		//즉, 스코프 안에서 함수를 정의하면 해당 스코프는 더 오래 유지되며, 일반적으로 접근할 수 없는 것에 접근할 수 있는 효과도 있음
		
		
		// Ex2)
		let f2;
		{
			let o = { note:'Safe'};
			f2 = function() {
				return o;
			}
		}
		
		let oRef = f2();
		oRef.note = "Not so safe after all!";
		console.log('7.6 함수 클로저, 정적 스코프 예제2: '+ oRef.note); // "Not so safe after all!"
		
		/*----------------------------------------------------------------------  
			< 7.7 즉시 호출하는 함수 표현식 >
			1. IIFE : 함수를 선언하고 즉시 실행
		---------------------------------------------------------------------- */
		// IIFE 형태
		(function() {
			// IIFE 바디
		})();
		
		
		// 장점 : 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE 자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다.
		const message = (function() {
			const secret = "I'm secret!"; // IIFE 스코프 안에서 안전하게 보호되며 외부에서 접근 불가능
			return `The secret is ${secret.length} characters long.`;
		})();
		console.log('7.7 즉시 호출하는 함수 표현식: '+ message); // The secret is 11 characters long.
		
		/*----------------------------------------------------------------------  
			< 7.8 함수 스코프와 호이스팅 >
			1. let으로 변수 선언 : 선언하기 전에 존재하지X
			2. var로 변수 선언 : 현재 스코프 안이라면 어디서든 사용가능, 선언 전에도 사용할 수 있음
			- 선언 전에 변수 접근이 가능한 이유 : 호이스팅 메커니즘을 따름
			- 자바스크립트는 함수나 전역 스코프 전체를 살펴보고 var로 선언한 변수를 맨 위로 끌어올린다.(* 선언만 끌어올려진다. 할당은 끌어올려지지X)
		---------------------------------------------------------------------- */
		// 원래 코드
		if(x3 !==3) {
			console.log('7.8 함수 스코프와 호이스팅 원래코드: '+ y3); //undefined
			var y3 = 5;
			if(y3 === 5) {
				var x3 = 3;
			}
			console.log('7.8 함수 스코프와 호이스팅 원래코드: '+ y3); // 5
		}
		if(x3 === 3) {
			console.log('7.8 함수 스코프와 호이스팅 원래코드: '+ y3); // 5
		}
		
		// 자바스크립트가 해석한 코드
//		var x3;
//		var y3;
//		if(x3 !== 3) {
//			console.log('7.8 함수 스코프와 호이스팅 자스 해석 코드: '+ y3); //undefined
//			y3 = 5;
//			if(y3 === 5) {
//				x3 = 3;
//			}
//			console.log('7.8 함수 스코프와 호이스팅 자스 해석 코드: '+ y3); // 5
//		}
//		if(x3 === 3) {
//			console.log('7.8 함수 스코프와 호이스팅 자스 해석 코드: '+ y3); // 5
//		}
		
		// var를 이용해 변수 선언하면 같은 변수를 여러 번 정의하더라도 무시함
		// 원래 코드
		var x4 = 3;
		if(x4 === 3) {
			var x4 = 2;
			console.log('7.8 함수 스코프와 호이스팅 원래코드 var이용: '+ x4); // 2
		}
		console.log('7.8 함수 스코프와 호이스팅 원래코드 var이용: '+ x4); // 2
		
		// 자바스크립트가 해석한 코드
//		var x;
//		x = 3;
//		if(x === 3) {
//			x = 2;
//			console.log(x);
//		}
//		console.log(x);
		
		/*----------------------------------------------------------------------  
			< 7.9 함수 호이스팅 >
			- 함수 선언도 스코프 맨 위로 끌어올려져 함수를 선언하기 전에 호출할 수 있다.
		---------------------------------------------------------------------- */
		f3(); // 7.9 함수 호이스팅
		function f3() {
			console.log('7.9 함수 호이스팅');
		}
		
		// but, 변수에 할당한 함수 표현식은 끌어올려지지 않고 변수 스코프 규칙을 그대로 따른다.
		f4(); // ReferrenceError: f는 정의되지 않았습니다.
		let f4 = function() {
			console.log('f4');
		}
		
		/*----------------------------------------------------------------------  
			< 7.10 사각지대 >
			- let으로 선언하는 변수는 선언하기 전까지 존재하지 않는다는 직관적인 개념을 잘 나타내는 표현
			- 스코프 안에서 변수의 사각지대 : 변수가 선언되지 전의 코드
			- typeof 연산자 : 변수가 선언됐는지 알아볼 때 널리 쓰이고, 존재를 확인하는 안전한 방법으로 알려져 있음. 
			그러나 let으로 변수 선언시에는 안전하지 않음
		---------------------------------------------------------------------- */
		
		
		/*----------------------------------------------------------------------  
			< 7.11 스트릭트 모드 >
			- "use strict" : 암시적 전역 변수를 허용하지X
			- 전역 스코프에 스트릭트 모드를 사용하면 스크립트 전체 동작 방식이 바뀐다.
		---------------------------------------------------------------------- */	
	</script>
</body>
</html>
